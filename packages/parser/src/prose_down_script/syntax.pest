keywords = { "eff" | "handle" | "trait" | "impl" | "where" | "data" | "fix" | "const" | "nominal" | "structual" }
lineComment = { ws* ~ "//" ~ (!br ~ ANY)* ~ (&EOI | br) }

// idents
ident = { varIdent | opIdent }
  opIdent = _{ "(" ~ operator ~ ")" }
varIdent = { !(&keywords) ~ ASCII_ALPHA_LOWER ~ ASCII_ALPHANUMERIC* }
typeIdent = { ASCII_ALPHA_UPPER ~ ASCII_ALPHANUMERIC* }
instIdent = { "@" ~ varIdent }
handlerIdent = { "*" ~ varIdent }

//
defOp = _{ ws* ~ "::" ~ ws* }
assignOp = _{ ws* ~ "=" ~ ws* }
assignArgs = { (ws+ ~ pattern)* }
whereClause = { (ws* ~ "where" ~ ws* ~ stmtsBlock)? }
etaEnvs = { ws* ~ ("<" ~ ws* ~ etaEnvN ~ ws* ~ ","? ~ ">")? }
  etaEnv = { ws* ~ varIdent ~ ws* ~ ":" ~ ws* ~ handlerTypeExpr }
  etaEnvN = _{ etaEnv ~ ws* ~ ("," ~ ws* ~ etaEnv)* }

// stmts
stmt = { ws* ~ (instTypeDef | handlerTypeDef | assignTypeDef | traitDef | handlerAssign | implAssign | dataAssign | assign) ~ ws* }
instTypeDef = { instIdent ~ defOp ~ typeExpr }
handlerTypeDef = { etaEnvs ~ ws* ~ handlerIdent ~ defOp ~ handlerDefTypeExpr }
assignTypeDef = { etaEnvs ~ ws* ~ ident ~ defOp ~ (typeExpr | coroutineTypeExpr) }
traitDef = { "trait" ~ ws+ ~ traitConstraintExprs ~ typeIdent ~ traitArgs ~ whereClause }
  traitArgs = { (ws+ ~ (varIdent | typeIdent))* }
  traitValue = _{ stmtsBlock | typeIdent }
  traitExpr = { ws* ~ ((traitValue ~ ws* ~ traitOp ~ ws* ~ traitValue ~ ws*)+ | traitValue) ~ ws* }
  traitOp = { traitOpAnd | traitOpOr }
    traitOpAnd = { "&" }
    traitOpOr = { "|" }
implAssign = { "impl" ~ ws+ ~ traitConstraintExprs ~ typeIdent ~ traitArgs ~ whereClause }
dataAssign = { dataModifier ~ "data" ~ ws+ ~ traitConstraintExprs ~ typeIdent ~ dataArgs ~ ws* ~ "=" ~ ws* ~ dataExpr }
  dataModifier = { ((dataModifierNominal | dataModifierStructual) ~ ws+)* }
    dataModifierNominal = { "nominal" }
    dataModifierStructual = { "structual" }
  dataArgs = { (ws+ ~ varIdent | typeIdent)* }
  dataExpr = { dataExprOr | dataValue }
    dataExprOr = { dataTerm ~ ws* ~ "|" ~ ws* ~ dataExpr }
    dataTerm = _{ dataValue }
    dataValueGroup = { "(" ~ ws* ~ dataExpr ~ ws* ~ ")" }
    dataValue = { dataValueGroup | dataValueContext | dataValueUnit | typeIdent | varIdent }
      dataValueContext = { (typeIdent | varIdent) ~ (ws+ ~ dataTerm)+ }
      dataValueUnit = { "(" ~ ws* ~ ")" }

// TODO: dataAssign
handlerAssign = { handlerIdent ~ assignArgs ~ assignOp ~ expr ~ whereClause? }
assign = { ident ~ assignArgs ~ assignOp ~ expr ~ whereClause }

// type exprs
typeExpr = { traitConstraintExprs ~ abstructionTypeExpr }
handlerDefTypeExpr = { traitConstraintExprs ~ handlerTypeExpr ~ abstructionTypeExpr }
coroutineTypeExpr = { traitConstraintExprs ~ handlerTypeExpr }
traitConstraintExprs = { (ws* ~ (traitConstraintGroup | traitConstraintExprN) ~ ws* ~ "=>" ~ ws*)? }
  traitConstraintExpr = { typeIdent ~ (ws+ ~ (typeIdent | varIdent))* }
  // TODO
  traitConstraintExprN = _{ traitConstraintExpr ~ ws* ~ ("," ~ ws* ~ traitConstraintExpr)* }
  traitConstraintGroup = _{ "(" ~ ws* ~ traitConstraintExprN ~ ws* ~ ")" }
handlerTypeExpr = { ws* ~ handlerTypeExpr1? }
  handlerTypeExpr1 = _{ "<" ~ ws* ~ abstructionTypeExpr ~ ws* ~ "," ~ ws* ~ abstructionTypeExpr ~ ws* ~ ">" }
abstructionTypeExpr = { ws* ~ (typeExprArrow | typeExprContext | typeExprGroup | typeExprLiteral) }
typeExprArrow = { (typeExprLiteral | typeExprGroup) ~ ws* ~ "->" ~ ws* ~ abstructionTypeExpr }
typeExprContext = { typeIdent ~ (ws+ ~ abstructionTypeExpr) }
typeExprGroup = { "(" ~ ws* ~ abstructionTypeExpr ~ ws* ~ ")" }
typeExprLiteral = { typeExprUnit | typeExprTuple | typeExprArray | typeExprDivergent | typeExprTop | typeIdent | varIdent }
  typeExprUnit = { "(" ~ ws* ~ ")" }
  typeExprTuple = { "(" ~ ws* ~ (typeExprTupleN | typeExprTuple1) ~ ws* ~ ")" }
    typeExprTuple1 = _{ abstructionTypeExpr ~ ws* ~ "," }
    typeExprTupleN = _{ abstructionTypeExpr ~ (ws* ~ "," ~ ws* ~ abstructionTypeExpr)+ ~ ws* ~ ","? }
  typeExprArray = { "[" ~ ws* ~ abstructionTypeExpr ~ ws* ~ "]" }
  typeExprDivergent = { "!" }
  typeExprTop = { "_" }

// exprs
expr = { (instApply | effApply | apply | withParen | variable | instIdent | ident | typeIdent | literal) ~ ws* ~ expr? }
// TODO: prefixOperator
// TODO: postfixOperator
infixOperator = { operator | infixIdent }
  operator = { operatorChar ~ (operatorChar | "#" | "@")* }
    operatorChar = _{ "." | "+" | "*" | "-" | "/" | "&" | "|" | ">" | "<" | "^" | "$" | "%" | ":" | "=" | "!" }
  infixIdent = { infixIdentSeparator ~ (!infixIdentSeparator ~ ident) ~ infixIdentSeparator }
    infixIdentSeparator = { "`" }
  literal = { arrayLiteral | tupleLiteral | charLiteral | textLiteral | intLiteral | unitLiteral }
    textLiteral = { "\"" ~ textChar* ~ "\"" }
      textChar = { !"\"" ~ textCharChar }
      textCharChar = _{ (textEscapedChar | ANY) }
        textEscapedChar = _{ "\\" ~ ANY }
    intLiteral = { "0" | (("+" | "-")?  ~ ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*) }
    charLiteral = { "'" ~ (("\\" ~ ANY) | ANY) ~ "'" }
    arrayLiteral = { "[" ~ expr* ~ "]"}
    unitLiteral = { "(" ~ ws* ~ ","? ~ ws* ~ ")" }
    tupleLiteral = { "(" ~ ws* ~ (tupleLiteralN | tupleLiteral1) ~ ws* ~ ")" }
      tupleLiteral1 = _{ expr ~ ws* ~ "," }
      tupleLiteralN = _{ expr ~ (ws* ~ "," ~ ws* ~ expr)+ ~ ws* ~ ","? }
  term = _{ withParen | variable | ident | literal }
  withParen = _{ "(" ~ ws* ~ expr ~ ws* ~ ")" }
  apply = { applyInfix | applyPrefix | applyPrefixOp }
    applyPrefix = { ident ~ (ws+ ~ expr)? }
    applyInfix = { term ~ ws* ~ infixOperator ~ ws* ~ expr }
    applyPrefixOp = { operator ~ expr }
      // TODO: applyInfixLeft
      // TODO: applyInfixRight
    // applyArgs = { (ws+ ~ (exprInfix | withParen | ident | literal))* }
  effApply = { "eff" ~ ws+ ~ handlerIdent ~ (ws+ ~ expr)? }
  instApply = { instIdent ~ (ws+ ~ expr)? }

// patterns
pattern = { patternOr | patternValue }
  patternValue = _{ patternAny | patternListHead | patternTypeIdent | patternIdent | patternLiteral | patternTuple }
    patternLiteral = { literal }
    patternIdent = { varIdent }
    patternTypeIdent = { typeIdent }
    patternListHead = { "[" ~ ws* ~ patternValue ~ ws* ~ ":" ~ ws* ~ pattern ~ ws* ~ "]" }
    patternAny = { "_" ~ varIdent? }
    patternTuple = { "(" ~ ws* ~ patternValue ~ ("," ~ ws* ~ pattern) ~ ws* ~ ")"}
    // TODO: patternData
  patternOr = { patternValue ~ ws* ~ "|" ~ ws* ~ pattern }

// terms
variable = { ident | referenceSelf | variableN | variable3 | variable2 | variable1 }
  variable1 = _{ "#" }
  variable2 = _{ "##" }
  variable3 = _{ "###" }
  variableN = _{ "#" ~ ASCII_DIGIT+ }
  referenceSelf= _{ "#%" }

stmtsBlock = { ws* ~ "{" ~ ws* ~ stmts ~ ws* ~ "}" ~ ws* }
stmtSep = _{ ";" }
stmts = _{ ws* ~ (stmt | (ws* ~ br) | lineComment | stmtSep)* ~ ws*}
pds = _{ ws* ~ stmts ~ ws* }
root = _{ pds? ~ br* ~ &EOI}
